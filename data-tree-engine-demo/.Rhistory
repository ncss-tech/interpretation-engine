x <- deratify(r, 'landcover')
x
plot(x)
set.seed(0)
r <- raster(nrow=10, ncol=10)
values(r) <- runif(ncell(r)) * 10
is.factor(r)
plot(r)
r <- round(r)
f <- as.factor(r)
is.factor(f)
plot(f)
x <- levels(f)[[1]]
x
x$code <- letters[10:20]
levels(f) <- x
levels(f)
f
plot(x)
plot(f)
x
plot(r)
rat <- levels(r)[[1]]
rat$landcover <- c('Pine', 'Oak', 'Meadow')
rat$code <- c(12,25,30)
levels(r) <- rat
plot(r)
rat <- levels(r)[[1]]
rat$landcover <- c('Pine', 'Oak', 'Meadow')
rat$code <- c(12,25,30)
levels(r) <- rat
plot(r)
rat
levels(r)
r <- raster(nrow=10, ncol=10)
values(r) = 1
r[51:100] = 2
r[3:6, 1:5] = 3
r <- ratify(r)
plot(r)
rat <- levels(r)[[1]]
rat
rat$landcover <- c('Pine', 'Oak', 'Meadow')
rat$code <- c(12,25,30)
levels(r) <- rat
plot(r)
levels(r)
# extract values for some cells
i <- extract(r, c(1,2, 25,100))
i
# get the attribute values for these cells
factorValues(r, i)
# create a single-layer factor
x <- deratify(r, 'landcover')
x
is.factor(x)
levels(x)
plot(x)
x$landcover
# create a single-layer factor
x <- deratify(r, 'landcover')
levels(x)
plot(x$landcover)
plot(levels(x$landcover))
### test params
load("datatree-hsg.rdata")
### test params
load("E:\\NMSU\\datatree-hsg.rdata")
load("E:\\NMSU\\tree_eval_testdata.rdata")
runparallel <- TRUE
ncores <- "auto"
require(data.tree)
require(foreach)
cl <- parallel::makeCluster(ncores)
if(ncores == "auto") ncores <- parallel::detectCores() - 2
cl <- parallel::makeCluster(ncores)
cat("Running parallel with", ncores, "cores")
doParallel::registerDoParallel(cl)
on.exit(try(stopCluster(cl)))
print("Running sequentially")
foreach::registerDoSEQ()
??registerDoParallel
??foreach
require(doParallel)
cl <- parallel::makeCluster(ncores)
cat("Running parallel with", ncores, "cores")
doParallel::registerDoParallel(cl)
on.exit(try(stopCluster(cl)))
print("Running sequentially")
foreach::registerDoSEQ()
cl <- parallel::makeCluster(ncores)
cat("Running parallel with", ncores, "cores")
doParallel::registerDoParallel(cl)
on.exit(try(stopCluster(cl)))
?iter
data <- df.spatialdata[1:50,]
data <- df.spatialdata[1:50,]
tree <- tr.hsg
out <- foreach(iter(data)) %dopar%{
parent = tree$root # parent holds the set of nodes to be evaluated; start as the root.
descend = F # when descend becomes true, the function has found the right path to follow and will look at the next set of siblings down
i = 1 # each child node of the current parent will be evaluated in turn, referred to by index "i"
node = parent$children[[i]] # node holds the exact logical node to be evaluated, the i'th node of parent
while(!isLeaf(node))  { # when the node is a leaf (end node), the function is done
# extract the name of the variable to evaluate
varname = node$var
# check to see if its in the input data
if(!(varname %in% colnames(data))) {
stop(paste(varname, "must be a column name in input data"))
}
# extract the value
value = data[,varname]
# if the value is na, this point can't be evaluated due to missing data
if(is.na(value) & !grepl("is.na", node$logical)) return(NA)
# change the logical string to use the generic 'value' instead of the specified variable name
# specific variable names are used in the tree objects for readability
lstr = gsub(varname, "value", node$logical)
# evaluate the logical string, storing T/F to 'descend'
descend = eval(parse(text = lstr))
# if descend is true, then this is the correct path. Set the current node as the parent, and start over!
if(descend) {
parent = node
i = 1
# if descend is false, check the next sibling node at this level
} else {
i = i + 1
}
# if there are no more children to evaluate, then there is an error in the logical pathway of the tree.
if(i > length(parent$children)) stop("Error: cannot solve this data point. Check for errors in the tree")
# otherwise, get the next node down and start evaluating again
node = parent$children[[i]]
}
return(node$name)
}
out <- foreach(iter(data)) %dopar%{
require(data.tree)
parent = tree$root # parent holds the set of nodes to be evaluated; start as the root.
descend = F # when descend becomes true, the function has found the right path to follow and will look at the next set of siblings down
i = 1 # each child node of the current parent will be evaluated in turn, referred to by index "i"
node = parent$children[[i]] # node holds the exact logical node to be evaluated, the i'th node of parent
while(!isLeaf(node))  { # when the node is a leaf (end node), the function is done
# extract the name of the variable to evaluate
varname = node$var
# check to see if its in the input data
if(!(varname %in% colnames(data))) {
stop(paste(varname, "must be a column name in input data"))
}
# extract the value
value = data[,varname]
# if the value is na, this point can't be evaluated due to missing data
if(is.na(value) & !grepl("is.na", node$logical)) return(NA)
# change the logical string to use the generic 'value' instead of the specified variable name
# specific variable names are used in the tree objects for readability
lstr = gsub(varname, "value", node$logical)
# evaluate the logical string, storing T/F to 'descend'
descend = eval(parse(text = lstr))
# if descend is true, then this is the correct path. Set the current node as the parent, and start over!
if(descend) {
parent = node
i = 1
# if descend is false, check the next sibling node at this level
} else {
i = i + 1
}
# if there are no more children to evaluate, then there is an error in the logical pathway of the tree.
if(i > length(parent$children)) stop("Error: cannot solve this data point. Check for errors in the tree")
# otherwise, get the next node down and start evaluating again
node = parent$children[[i]]
}
return(node$name)
}
out
unlist(out)
data <- na.omit(df.spatialdata)[1:50,]
tree <- tr.hsg
if(ncores == "auto") ncores <- parallel::detectCores() - 2
if (ncores > 1) {
cl <- parallel::makeCluster(ncores)
cat("Running parallel with", ncores, "cores")
doParallel::registerDoParallel(cl)
on.exit(try(stopCluster(cl)))
} else {
print("Running sequentially")
foreach::registerDoSEQ()
}
out <- foreach(iter(data)) %dopar%{
require(data.tree)
parent = tree$root # parent holds the set of nodes to be evaluated; start as the root.
descend = F # when descend becomes true, the function has found the right path to follow and will look at the next set of siblings down
i = 1 # each child node of the current parent will be evaluated in turn, referred to by index "i"
node = parent$children[[i]] # node holds the exact logical node to be evaluated, the i'th node of parent
while(!isLeaf(node))  { # when the node is a leaf (end node), the function is done
# extract the name of the variable to evaluate
varname = node$var
# check to see if its in the input data
if(!(varname %in% colnames(data))) {
stop(paste(varname, "must be a column name in input data"))
}
# extract the value
value = data[,varname]
# if the value is na, this point can't be evaluated due to missing data
if(is.na(value) & !grepl("is.na", node$logical)) return(NA)
# change the logical string to use the generic 'value' instead of the specified variable name
# specific variable names are used in the tree objects for readability
lstr = gsub(varname, "value", node$logical)
# evaluate the logical string, storing T/F to 'descend'
descend = eval(parse(text = lstr))
# if descend is true, then this is the correct path. Set the current node as the parent, and start over!
if(descend) {
parent = node
i = 1
# if descend is false, check the next sibling node at this level
} else {
i = i + 1
}
# if there are no more children to evaluate, then there is an error in the logical pathway of the tree.
if(i > length(parent$children)) stop("Error: cannot solve this data point. Check for errors in the tree")
# otherwise, get the next node down and start evaluating again
node = parent$children[[i]]
}
return(node$name)
}
out
unlist(out)
ncores <- 1
stop(cat("Cannot run with", ncores, "as your computer only has", detectCores(), "cores."))
stop(cat("Cannot run with", ncores, "cores as your computer only has", detectCores()))
# Decision tree evaluation for data.tree
# Joe Brehm
# Last edited 8/31/2020
# this function evaluates decision trees stored as data.tree type objects
# input requirements are fairly specific: see the associated tree creation files for how to create trees that can work here
# TO DO:
## rewrite the NA checks so that it string searches the entire set of sibling evaluations -- so you don't need !is.na() everywhere
## better error reporting:
#### "cannot solve" to include where in the tree it is looking
### test params
#load("E:\\NMSU\\datatree-hsg.rdata")
#load("E:\\NMSU\\tree_eval_testdata.rdata")
#ncores <- 1
#require(data.tree)
#require(foreach)
#require(doParallel)
#data <- na.omit(df.spatialdata)[1:50,]
#tree <- tr.hsg
tree_eval <- function(
tree,
# tree is a data tree object structured with classifications as leaves
# above those, all nodes must contain these attributes:
# "var", specifying the variable name to evaluate,
# "logical", specifying the logical evaluation at that step. MUST INCLUDE THE SAME VARIABLE "VAR"
data,
# data must be a data frame containing columns with names matching all the values of "var" used in the tree object
ncores = 1
# number of cores to parallelize over.
# if set to 1 (default), runs sequentially
# Also accepts "auto" as input. Will run with ncores on computer - 2
){
if(ncores == "auto") {
if(detectCores() == 2) {
ncores = 1
} else {
ncores <- parallel::detectCores() - 2
}
}
if(ncores > detectCores()){
stop(cat("Cannot run with", ncores, "cores as your computer only has", detectCores()))
}
if (ncores > 1) {
cl <- parallel::makeCluster(ncores)
cat("Running parallel with", ncores, "cores")
doParallel::registerDoParallel(cl)
on.exit(try(stopCluster(cl)))
} else {
print("Running sequentially")
foreach::registerDoSEQ()
}
out <- foreach(iter(data)) %dopar%{
require(data.tree)
parent = tree$root # parent holds the set of nodes to be evaluated; start as the root.
descend = F # when descend becomes true, the function has found the right path to follow and will look at the next set of siblings down
i = 1 # each child node of the current parent will be evaluated in turn, referred to by index "i"
node = parent$children[[i]] # node holds the exact logical node to be evaluated, the i'th node of parent
while(!isLeaf(node))  { # when the node is a leaf (end node), the function is done
# extract the name of the variable to evaluate
varname = node$var
# check to see if its in the input data
if(!(varname %in% colnames(data))) {
stop(paste(varname, "must be a column name in input data"))
}
# extract the value
value = data[,varname]
# if the value is na, this point can't be evaluated due to missing data
if(is.na(value) & !grepl("is.na", node$logical)) return(NA)
# change the logical string to use the generic 'value' instead of the specified variable name
# specific variable names are used in the tree objects for readability
lstr = gsub(varname, "value", node$logical)
# evaluate the logical string, storing T/F to 'descend'
descend = eval(parse(text = lstr))
# if descend is true, then this is the correct path. Set the current node as the parent, and start over!
if(descend) {
parent = node
i = 1
# if descend is false, check the next sibling node at this level
} else {
i = i + 1
}
# if there are no more children to evaluate, then there is an error in the logical pathway of the tree.
if(i > length(parent$children)) stop("Error: cannot solve this data point. Check for errors in the tree")
# otherwise, get the next node down and start evaluating again
node = parent$children[[i]]
}
return(node$name)
}
return(unlist(out))
}
### 0 load packages, workspace, functions, and data ####
library(rgdal)
library(tidyverse)
library(rgeos)
library(rasterVis)
library(parallel)
library(foreach)
# set working directory
setwd("E:/NMSU/interpretation-engine/data-tree-engine-demo")
# load data.tree engine functions
load("datatree_hsg.rdata") # loads tr.hsg
load("datatree_svi.rdata") # loads tr.svi
source("tree_eval.r")
# view interp trees
# logical holds the precise logical statement defining each node
print(tr.hsg, "logical")
print(tr.svi, "logical")
# var is the name of the variable used by that node -- required for how tree_eval is written currently
# "classification" is assigned to leaf nodes. It isn't actually required, or ever referred to. Could be any name, or NA
print(tr.hsg, "var")
print(tr.svi, "var")
# load raster brick, all preprocessed already
load("Duchesne100100_treecalcBrick_InData.rdata")
# names have to be these, exactly. Order doesn't matter. Extra layers in the brick are fine
names(brk.in) <- c("wt", "rl", "kw", "ksat", "slope")
### 1 run the tree evaluation ####
### 1.1 - HSG
### currently this works fastest when taking a dataframe as input -- conversion from brick is easy though
df.in <- as.data.frame(brk.in)
df.out <- df.in
### 0 load packages, workspace, functions, and data ####
library(rgdal)
library(tidyverse)
library(rgeos)
library(rasterVis)
library(parallel)
library(foreach)
# set working directory
setwd("E:/NMSU/interpretation-engine/data-tree-engine-demo")
# load data.tree engine functions
load("datatree_hsg.rdata") # loads tr.hsg
load("datatree_svi.rdata") # loads tr.svi
source("tree_eval.r")
# view interp trees
# logical holds the precise logical statement defining each node
print(tr.hsg, "logical")
print(tr.svi, "logical")
# var is the name of the variable used by that node -- required for how tree_eval is written currently
# "classification" is assigned to leaf nodes. It isn't actually required, or ever referred to. Could be any name, or NA
print(tr.hsg, "var")
print(tr.svi, "var")
# load raster brick, all preprocessed already
load("Duchesne100100_treecalcBrick_InData.rdata")
# names have to be these, exactly. Order doesn't matter. Extra layers in the brick are fine
names(brk.in) <- c("wt", "rl", "kw", "ksat", "slope")
### 1 run the tree evaluation ####
### 1.1 - HSG
### currently this works fastest when taking a dataframe as input -- conversion from brick is easy though
df.in <- as.data.frame(brk.in)
df.out <- df.in
# # run sequentially
# t1 <- Sys.time()
# df.out$hsg <-
#   tree_eval(tree = tr.hsg,
#             indata = df.in,
#             ncores = 1)
# t2 <- Sys.time()
# print(t2 - t1)
# run parallel
t3 <- Sys.time()
df.out$hsg <-
tree_eval(tree = tr.hsg,
indata = df.in,
ncores = "auto")
t4 <- Sys.time()
brk.out <- brk.in
# run parallel
t3 <- Sys.time()
brk.out$hsg <-
tree_eval(tree = tr.hsg,
indata = brk.in,
ncores = "auto")
t4 <- Sys.time()
source("tree_eval.r")
brk.out$hsg <-
tree_eval(tree = tr.hsg,
indata = brk.in,
ncores = "auto")
df.out <- df.in
t3 <- Sys.time()
df.out$hsg <-
tree_eval(tree = tr.hsg,
indata = df.in,
ncores = "auto")
t4 <- Sys.time()
t4 - t3
# back to raster
brk.out <- brk.in
brk.out$hsg <-
raster::replacement(brk.out$hsg, df.out$hsg)
brk.subset$hsg <-
brk.subset$wt %>%
setValues(factor(df.spatialdata$hsg,
levels = rev(c("A", "A/D", "B", "B/D", "C", "C/D", "D"))))
brk.out$hsg <-
brk.out$wt %>%
setValues(factor(df.out$hsg,
levels = rev(c("A", "A/D", "B", "B/D", "C", "C/D", "D"))))
plot(brk.out$hsg)
# plot
levelplot(brk.subset$hsg,
col.regions=terrain.colors(7),
xlab="Easting",
ylab="Northing")
# plot
levelplot(brk.out$hsg,
col.regions=terrain.colors(7),
xlab="Easting",
ylab="Northing")
### 1.2 SVI
# need to get the primary HSG for SVI calculation
df.out$shorthsg <-
sapply(df.out$hsg,
function(h){
strsplit(h,
"/")[[1]][1]
})
# run parallel
t7 <- Sys.time()
df.out$hsg <-
tree_eval(tree = tr.hsg,
indata = df.in,
ncores = "auto")
t8 <- Sys.time()
print(t8 - t7)
df.out$shorthsg <-
sapply(df.out$hsg,
function(h){
strsplit(h,
"/")[[1]][1]
})
# run parallel
t7 <- Sys.time()
df.out$svi <-
tree_eval(tree = tr.svi,
indata = df.in,
ncores = "auto")
t8 <- Sys.time()
print(t8 - t7)
#
df.out$shorthsg <-
sapply(df.out$hsg,
function(h){
strsplit(h,
"/")[[1]][1]
})
df.out$shorthsg
View(df.out)
t7 <- Sys.time()
df.out$svi <-
tree_eval(tree = tr.svi,
indata = df.out,
ncores = "auto")
t8 <- Sys.time()
print(t8 - t7)
# back to raster
brk.subset$svi <-
brk.subset$wt %>%
setValues(factor(df.spatialdata$svi,
levels = rev(c("1 - Low", "2 - Moderately Low", "3 - Moderately High", "4 - High"))))
# back to raster
df.out$svi <-
df.out$wt %>%
setValues(factor(df.out$svi,
levels = rev(c("1 - Low", "2 - Moderately Low", "3 - Moderately High", "4 - High"))))
# back to raster
brk.out$svi <-
brk.out$wt %>%
setValues(factor(brk.out$svi,
levels = rev(c("1 - Low", "2 - Moderately Low", "3 - Moderately High", "4 - High"))))
# back to raster
brk.out$svi <-
brk.out$wt %>%
setValues(factor(df.out$svi,
levels = rev(c("1 - Low", "2 - Moderately Low", "3 - Moderately High", "4 - High"))))
#plot
levelplot(df.out$svi,
col.regions=terrain.colors(4),
xlab="Easting",
ylab="Northing")
df.out$svi
#plot
levelplot(brk.out$svi,
col.regions=terrain.colors(4),
xlab="Easting",
ylab="Northing")
