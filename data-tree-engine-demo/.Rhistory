tr.hsg$`Moderate depth restrictive layer`$`Deep water table`$`Moderate-low conductivity`$AddChild(
"C",
var = "classification")
tr.hsg$`Moderate depth restrictive layer`$`Deep water table`$`Low conductivity`$AddChild(
"D",
var = "classification")
### level 3c ksat, deep rl, shallow wt###
tr.hsg$`Deep restrictive layer`$`Shallow water table`$AddChild("High conductivity",
logical = "ksat > 10",
var = "ksat")
tr.hsg$`Deep restrictive layer`$`Shallow water table`$AddChild("Moderate-high conductivity",
logical = "ksat <= 10 & ksat > 4",
var = "ksat")
tr.hsg$`Deep restrictive layer`$`Shallow water table`$AddChild("Moderate-low conductivity",
logical = "ksat <= 4 & ksat > 0.4",
var = "ksat")
tr.hsg$`Deep restrictive layer`$`Shallow water table`$AddChild("Low conductivity",
logical = "ksat <= 0.4",
var = "ksat")
tr.hsg$`Deep restrictive layer`$`Shallow water table`$`High conductivity`$AddChild(
"A/D",
var = "classification")
tr.hsg$`Deep restrictive layer`$`Shallow water table`$`Moderate-high conductivity`$AddChild(
"B/D",
var = "classification")
tr.hsg$`Deep restrictive layer`$`Shallow water table`$`Moderate-low conductivity`$AddChild(
"C/D",
var = "classification")
tr.hsg$`Deep restrictive layer`$`Shallow water table`$`Low conductivity`$AddChild(
"D",
var = "classification")
### level 3d ksat, deep rl, moderate wt###
tr.hsg$`Deep restrictive layer`$`Moderate depth water table`$AddChild("High conductivity",
logical = "ksat > 40",
var = "ksat")
tr.hsg$`Deep restrictive layer`$`Moderate depth water table`$AddChild("Moderate-high conductivity",
logical = "ksat <= 40 & ksat > 10",
var = "ksat")
tr.hsg$`Deep restrictive layer`$`Moderate depth water table`$AddChild("Moderate-low conductivity",
logical = "ksat <= 10 & ksat > 1",
var = "ksat")
tr.hsg$`Deep restrictive layer`$`Moderate depth water table`$AddChild("Low conductivity",
logical = "ksat <= 1",
var = "ksat")
tr.hsg$`Deep restrictive layer`$`Moderate depth water table`$`High conductivity`$AddChild(
"A",
var = "classification")
tr.hsg$`Deep restrictive layer`$`Moderate depth water table`$`Moderate-high conductivity`$AddChild(
"B",
var = "classification")
tr.hsg$`Deep restrictive layer`$`Moderate depth water table`$`Moderate-low conductivity`$AddChild(
"C",
var = "classification")
tr.hsg$`Deep restrictive layer`$`Moderate depth water table`$`Low conductivity`$AddChild(
"D",
var = "classification")
### level 3d ksat, deep rl, deep wt###
tr.hsg$`Deep restrictive layer`$`Deep water table`$AddChild("High conductivity",
logical = "ksat > 10",
var = "ksat")
tr.hsg$`Deep restrictive layer`$`Deep water table`$AddChild("Moderate-high conductivity",
logical = "ksat <= 10 & ksat > 4",
var = "ksat")
tr.hsg$`Deep restrictive layer`$`Deep water table`$AddChild("Moderate-low conductivity",
logical = "ksat <= 4 & ksat > .4",
var = "ksat")
tr.hsg$`Deep restrictive layer`$`Deep water table`$AddChild("Low conductivity",
logical = "ksat <= .4",
var = "ksat")
##
tr.hsg$`Deep restrictive layer`$`Deep water table`$`High conductivity`$AddChild(
"A",
var = "classification")
tr.hsg$`Deep restrictive layer`$`Deep water table`$`Moderate-high conductivity`$AddChild(
"B",
var = "classification")
tr.hsg$`Deep restrictive layer`$`Deep water table`$`Moderate-low conductivity`$AddChild(
"C",
var = "classification")
tr.hsg$`Deep restrictive layer`$`Deep water table`$`Low conductivity`$AddChild(
"D",
var = "classification")
tr.hsg
save(tr.hsg, file = "datatree-hsg.rdata")
# these are the two data.tree objects containing all of the rulesets. They are defined in another file.
load("datatree-hsg.rdata")
load("datatree-svi.rdata")
print(tr.hsg)
print(tr.hsg, "logical")
print(tr.hsg)
print(tr.hsg, "logical")
set.seed(0)
r <- raster(nrow=10, ncol=10)
values(r) <- runif(ncell(r)) * 10
is.factor(r)
r <- round(r)
f <- as.factor(r)
is.factor(f)
x <- levels(f)[[1]]
x
x$code <- letters[10:20]
levels(f) <- x
levels(f)
f
r <- raster(nrow=10, ncol=10)
values(r) = 1
r[51:100] = 2
r[3:6, 1:5] = 3
r <- ratify(r)
rat <- levels(r)[[1]]
rat$landcover <- c('Pine', 'Oak', 'Meadow')
rat$code <- c(12,25,30)
levels(r) <- rat
r
# extract values for some cells
i <- extract(r, c(1,2, 25,100))
i
# get the attribute values for these cells
factorValues(r, i)
# write to file:
# rr <- writeRaster(r, rasterTmpFile(), overwrite=TRUE)
# rr
# create a single-layer factor
x <- deratify(r, 'landcover')
x
is.factor(x)
levels(x)
library(raster)
set.seed(0)
r <- raster(nrow=10, ncol=10)
values(r) <- runif(ncell(r)) * 10
is.factor(r)
r <- round(r)
f <- as.factor(r)
is.factor(f)
x <- levels(f)[[1]]
x
x$code <- letters[10:20]
levels(f) <- x
levels(f)
f
r <- raster(nrow=10, ncol=10)
values(r) = 1
r[51:100] = 2
r[3:6, 1:5] = 3
r <- ratify(r)
rat <- levels(r)[[1]]
rat$landcover <- c('Pine', 'Oak', 'Meadow')
rat$code <- c(12,25,30)
levels(r) <- rat
r
# extract values for some cells
i <- extract(r, c(1,2, 25,100))
i
# get the attribute values for these cells
factorValues(r, i)
# write to file:
# rr <- writeRaster(r, rasterTmpFile(), overwrite=TRUE)
# rr
# create a single-layer factor
x <- deratify(r, 'landcover')
x
is.factor(x)
levels(x)
plot(x)
# get the attribute values for these cells
factorValues(r, i)
# create a single-layer factor
x <- deratify(r, 'landcover')
x
plot(x)
set.seed(0)
r <- raster(nrow=10, ncol=10)
values(r) <- runif(ncell(r)) * 10
is.factor(r)
plot(r)
r <- round(r)
f <- as.factor(r)
is.factor(f)
plot(f)
x <- levels(f)[[1]]
x
x$code <- letters[10:20]
levels(f) <- x
levels(f)
f
plot(x)
plot(f)
x
plot(r)
rat <- levels(r)[[1]]
rat$landcover <- c('Pine', 'Oak', 'Meadow')
rat$code <- c(12,25,30)
levels(r) <- rat
plot(r)
rat <- levels(r)[[1]]
rat$landcover <- c('Pine', 'Oak', 'Meadow')
rat$code <- c(12,25,30)
levels(r) <- rat
plot(r)
rat
levels(r)
r <- raster(nrow=10, ncol=10)
values(r) = 1
r[51:100] = 2
r[3:6, 1:5] = 3
r <- ratify(r)
plot(r)
rat <- levels(r)[[1]]
rat
rat$landcover <- c('Pine', 'Oak', 'Meadow')
rat$code <- c(12,25,30)
levels(r) <- rat
plot(r)
levels(r)
# extract values for some cells
i <- extract(r, c(1,2, 25,100))
i
# get the attribute values for these cells
factorValues(r, i)
# create a single-layer factor
x <- deratify(r, 'landcover')
x
is.factor(x)
levels(x)
plot(x)
x$landcover
# create a single-layer factor
x <- deratify(r, 'landcover')
levels(x)
plot(x$landcover)
plot(levels(x$landcover))
### test params
load("datatree-hsg.rdata")
### test params
load("E:\\NMSU\\datatree-hsg.rdata")
load("E:\\NMSU\\tree_eval_testdata.rdata")
runparallel <- TRUE
ncores <- "auto"
require(data.tree)
require(foreach)
cl <- parallel::makeCluster(ncores)
if(ncores == "auto") ncores <- parallel::detectCores() - 2
cl <- parallel::makeCluster(ncores)
cat("Running parallel with", ncores, "cores")
doParallel::registerDoParallel(cl)
on.exit(try(stopCluster(cl)))
print("Running sequentially")
foreach::registerDoSEQ()
??registerDoParallel
??foreach
require(doParallel)
cl <- parallel::makeCluster(ncores)
cat("Running parallel with", ncores, "cores")
doParallel::registerDoParallel(cl)
on.exit(try(stopCluster(cl)))
print("Running sequentially")
foreach::registerDoSEQ()
cl <- parallel::makeCluster(ncores)
cat("Running parallel with", ncores, "cores")
doParallel::registerDoParallel(cl)
on.exit(try(stopCluster(cl)))
?iter
data <- df.spatialdata[1:50,]
data <- df.spatialdata[1:50,]
tree <- tr.hsg
out <- foreach(iter(data)) %dopar%{
parent = tree$root # parent holds the set of nodes to be evaluated; start as the root.
descend = F # when descend becomes true, the function has found the right path to follow and will look at the next set of siblings down
i = 1 # each child node of the current parent will be evaluated in turn, referred to by index "i"
node = parent$children[[i]] # node holds the exact logical node to be evaluated, the i'th node of parent
while(!isLeaf(node))  { # when the node is a leaf (end node), the function is done
# extract the name of the variable to evaluate
varname = node$var
# check to see if its in the input data
if(!(varname %in% colnames(data))) {
stop(paste(varname, "must be a column name in input data"))
}
# extract the value
value = data[,varname]
# if the value is na, this point can't be evaluated due to missing data
if(is.na(value) & !grepl("is.na", node$logical)) return(NA)
# change the logical string to use the generic 'value' instead of the specified variable name
# specific variable names are used in the tree objects for readability
lstr = gsub(varname, "value", node$logical)
# evaluate the logical string, storing T/F to 'descend'
descend = eval(parse(text = lstr))
# if descend is true, then this is the correct path. Set the current node as the parent, and start over!
if(descend) {
parent = node
i = 1
# if descend is false, check the next sibling node at this level
} else {
i = i + 1
}
# if there are no more children to evaluate, then there is an error in the logical pathway of the tree.
if(i > length(parent$children)) stop("Error: cannot solve this data point. Check for errors in the tree")
# otherwise, get the next node down and start evaluating again
node = parent$children[[i]]
}
return(node$name)
}
out <- foreach(iter(data)) %dopar%{
require(data.tree)
parent = tree$root # parent holds the set of nodes to be evaluated; start as the root.
descend = F # when descend becomes true, the function has found the right path to follow and will look at the next set of siblings down
i = 1 # each child node of the current parent will be evaluated in turn, referred to by index "i"
node = parent$children[[i]] # node holds the exact logical node to be evaluated, the i'th node of parent
while(!isLeaf(node))  { # when the node is a leaf (end node), the function is done
# extract the name of the variable to evaluate
varname = node$var
# check to see if its in the input data
if(!(varname %in% colnames(data))) {
stop(paste(varname, "must be a column name in input data"))
}
# extract the value
value = data[,varname]
# if the value is na, this point can't be evaluated due to missing data
if(is.na(value) & !grepl("is.na", node$logical)) return(NA)
# change the logical string to use the generic 'value' instead of the specified variable name
# specific variable names are used in the tree objects for readability
lstr = gsub(varname, "value", node$logical)
# evaluate the logical string, storing T/F to 'descend'
descend = eval(parse(text = lstr))
# if descend is true, then this is the correct path. Set the current node as the parent, and start over!
if(descend) {
parent = node
i = 1
# if descend is false, check the next sibling node at this level
} else {
i = i + 1
}
# if there are no more children to evaluate, then there is an error in the logical pathway of the tree.
if(i > length(parent$children)) stop("Error: cannot solve this data point. Check for errors in the tree")
# otherwise, get the next node down and start evaluating again
node = parent$children[[i]]
}
return(node$name)
}
out
unlist(out)
data <- na.omit(df.spatialdata)[1:50,]
tree <- tr.hsg
if(ncores == "auto") ncores <- parallel::detectCores() - 2
if (ncores > 1) {
cl <- parallel::makeCluster(ncores)
cat("Running parallel with", ncores, "cores")
doParallel::registerDoParallel(cl)
on.exit(try(stopCluster(cl)))
} else {
print("Running sequentially")
foreach::registerDoSEQ()
}
out <- foreach(iter(data)) %dopar%{
require(data.tree)
parent = tree$root # parent holds the set of nodes to be evaluated; start as the root.
descend = F # when descend becomes true, the function has found the right path to follow and will look at the next set of siblings down
i = 1 # each child node of the current parent will be evaluated in turn, referred to by index "i"
node = parent$children[[i]] # node holds the exact logical node to be evaluated, the i'th node of parent
while(!isLeaf(node))  { # when the node is a leaf (end node), the function is done
# extract the name of the variable to evaluate
varname = node$var
# check to see if its in the input data
if(!(varname %in% colnames(data))) {
stop(paste(varname, "must be a column name in input data"))
}
# extract the value
value = data[,varname]
# if the value is na, this point can't be evaluated due to missing data
if(is.na(value) & !grepl("is.na", node$logical)) return(NA)
# change the logical string to use the generic 'value' instead of the specified variable name
# specific variable names are used in the tree objects for readability
lstr = gsub(varname, "value", node$logical)
# evaluate the logical string, storing T/F to 'descend'
descend = eval(parse(text = lstr))
# if descend is true, then this is the correct path. Set the current node as the parent, and start over!
if(descend) {
parent = node
i = 1
# if descend is false, check the next sibling node at this level
} else {
i = i + 1
}
# if there are no more children to evaluate, then there is an error in the logical pathway of the tree.
if(i > length(parent$children)) stop("Error: cannot solve this data point. Check for errors in the tree")
# otherwise, get the next node down and start evaluating again
node = parent$children[[i]]
}
return(node$name)
}
out
unlist(out)
ncores <- 1
stop(cat("Cannot run with", ncores, "as your computer only has", detectCores(), "cores."))
stop(cat("Cannot run with", ncores, "cores as your computer only has", detectCores()))
# Decision tree evaluation for data.tree
# Joe Brehm
# Last edited 8/31/2020
# this function evaluates decision trees stored as data.tree type objects
# input requirements are fairly specific: see the associated tree creation files for how to create trees that can work here
# TO DO:
## rewrite the NA checks so that it string searches the entire set of sibling evaluations -- so you don't need !is.na() everywhere
## better error reporting:
#### "cannot solve" to include where in the tree it is looking
### test params
#load("E:\\NMSU\\datatree-hsg.rdata")
#load("E:\\NMSU\\tree_eval_testdata.rdata")
#ncores <- 1
#require(data.tree)
#require(foreach)
#require(doParallel)
#data <- na.omit(df.spatialdata)[1:50,]
#tree <- tr.hsg
tree_eval <- function(
tree,
# tree is a data tree object structured with classifications as leaves
# above those, all nodes must contain these attributes:
# "var", specifying the variable name to evaluate,
# "logical", specifying the logical evaluation at that step. MUST INCLUDE THE SAME VARIABLE "VAR"
data,
# data must be a data frame containing columns with names matching all the values of "var" used in the tree object
ncores = 1
# number of cores to parallelize over.
# if set to 1 (default), runs sequentially
# Also accepts "auto" as input. Will run with ncores on computer - 2
){
if(ncores == "auto") {
if(detectCores() == 2) {
ncores = 1
} else {
ncores <- parallel::detectCores() - 2
}
}
if(ncores > detectCores()){
stop(cat("Cannot run with", ncores, "cores as your computer only has", detectCores()))
}
if (ncores > 1) {
cl <- parallel::makeCluster(ncores)
cat("Running parallel with", ncores, "cores")
doParallel::registerDoParallel(cl)
on.exit(try(stopCluster(cl)))
} else {
print("Running sequentially")
foreach::registerDoSEQ()
}
out <- foreach(iter(data)) %dopar%{
require(data.tree)
parent = tree$root # parent holds the set of nodes to be evaluated; start as the root.
descend = F # when descend becomes true, the function has found the right path to follow and will look at the next set of siblings down
i = 1 # each child node of the current parent will be evaluated in turn, referred to by index "i"
node = parent$children[[i]] # node holds the exact logical node to be evaluated, the i'th node of parent
while(!isLeaf(node))  { # when the node is a leaf (end node), the function is done
# extract the name of the variable to evaluate
varname = node$var
# check to see if its in the input data
if(!(varname %in% colnames(data))) {
stop(paste(varname, "must be a column name in input data"))
}
# extract the value
value = data[,varname]
# if the value is na, this point can't be evaluated due to missing data
if(is.na(value) & !grepl("is.na", node$logical)) return(NA)
# change the logical string to use the generic 'value' instead of the specified variable name
# specific variable names are used in the tree objects for readability
lstr = gsub(varname, "value", node$logical)
# evaluate the logical string, storing T/F to 'descend'
descend = eval(parse(text = lstr))
# if descend is true, then this is the correct path. Set the current node as the parent, and start over!
if(descend) {
parent = node
i = 1
# if descend is false, check the next sibling node at this level
} else {
i = i + 1
}
# if there are no more children to evaluate, then there is an error in the logical pathway of the tree.
if(i > length(parent$children)) stop("Error: cannot solve this data point. Check for errors in the tree")
# otherwise, get the next node down and start evaluating again
node = parent$children[[i]]
}
return(node$name)
}
return(unlist(out))
}
source(".\tree_eval.r")
getwd()
getSrcDirectory()[1]
rstudioapi::getActiveDocumentContext
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# load data.tree engine functions
load("datatree_hsg.rdata") # loads tr.hsg
load("datatree_svi.rdata") # loads tr.svi
source(".\tree_eval.r")
source("../tree_eval.r")
# view interp trees
# logical holds the precise logical statement defining each node
print(tr.hsg, "logical")
print(tr.svi, "logical")
# var is the name of the variable used by that node -- required for how tree_eval is written currently
# "classification" is assigned to leaf nodes. It isn't actually required, or ever referred to. Could be any name, or NA
print(tr.hsg, "var")
print(tr.svi, "var")
# load raster brick, all preprocessed already
load("Duchesne100100_treecalcBrick_InData.rdata")
# names have to be these, exactly. Order doesn't matter. Extra layers in the brick are fine
names(brk.in) <- c("wt", "rl", "kw", "ksat", "slope")
# set working directory to folder where this is saved
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# load data.tree engine functions
load("../datatree_hsg.rdata") # loads tr.hsg
load("../datatree_svi.rdata") # loads tr.svi
source("../tree_eval.r")
