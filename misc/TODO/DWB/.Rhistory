# set study area polygon (save a sf file to "sf.studyarea")
# set study area polygon (save a sf file to "sf.studyarea")
sf.studyarea <-
sf::st_read(dsn = "E:/NMSU/GIS/Utah_County_Boundaries-shp", layer = "Counties") %>%
st_make_valid() %>% st_transform(crs)
if(!is.null(county))  sf.studyarea <- sf.studyarea %>% subset(NAME == county)
# set path to a local gssurgo (needed for the rasterization step)
path.gssurgo <- paste0("../../../Data/gSSURGO/gSSURGO_", state, ".gdb")
### local funs
source("E:/NMSU/interp-engine-personal/Functions/dwb_calc2.r")
source('../../Functions/local-functions.R')
source("../../Functions/pull_SDA2_compandup.r")
### local data
dbcrosswalk <-
read.csv(paste0("../../dbcrosswalk/dbcrosswalk_inner_", state, ".csv"))
# this data cache is essential, it contains all the evaluations data
load('../cached-NASIS-data.Rda')
### need a list of component keys to access. this is created by getting all the components from the specified state
sda <- pull_SDA_compup(asym = state, fun = "like")
v.cokey <- sda$component$cokey %>% unique() %>% as.integer()
### take the list of cokeys, turn it into a list of coiids, because the data we need is in NASIS
v.coiid <- dbcrosswalk[dbcrosswalk$cokey %in% v.cokey, "coiid"] %>% as.character() %>% as.vector()
### loading the nasis data is slow, and *must* save intermediates along the way. This code does this by saving chunks of 100 components at a time
v.splitcoiid <- split(v.coiid, ceiling(seq_along(v.coiid)/100))
### load the interp tree from the nasis data cache
dt <- initRuleset('ENG - Dwellings With Basements')
ps <- getPropertySet(dt)
### 2.1 write property data to disk###
### iterate through the split list, pulling in the properties specified in 'ps' and saving them. THIS IS EASILY THE SLOWEST STEP
for(i in 1:length(v.splitcoiid)){
name <- paste0("Table Properties/DWBpropertyChunk", state, i, ".rdata")
print(name)
if(file.exists(name))
{
## all this code does is write the files; no action taken if the file exists
} else {
vv <- v.splitcoiid[[i]]
l.props <- list()
for(j in 1:length(vv)){
l.props[[j]] <- lookupProperties(
coiid = vv[j],
propIDs = unique(ps$propiid)
)
}
save(
l.props,
file = outname
)
}
}
### 2.2 read property chunks back into R ###
t.nasisdata <- data.frame(propiid = "",
coiid = "",
comp_name = "",
comp_pct = "",
rv = "")
v.paths <- list.files(path = "Table Properties", pattern = paste0("DWBpropertyChunk", state), full.names = T)
for(i in 1:length(v.paths)){
load(v.paths[i])
#print(i)
t <- do.call(rbind, l.props)
t.nasisdata <- rbind(t.nasisdata, t)
}
t.nasisdata$coiid <- as.character(t.nasisdata$coiid)
dbcrosswalk$coiid <- as.character(dbcrosswalk$coiid)
t.nasisjoin <-
left_join(
t.nasisdata,
ps[,c("propiid", "propname")],
by = "propiid"
) %>%
distinct() %>%
pivot_wider(
id_cols = c(coiid, comp_name),
names_from = propname,
values_from = rv,
values_fn = first) %>%
left_join(
dbcrosswalk
)
head(t.nasisjoin)
## rename the nasis data to more concise names, ensure all data types are correct, and process the non-numeric rasters into logicals
t.nasisrename <-
t.nasisjoin %>% dplyr::rename(
depbrockhard = `DEPTH TO BEDROCK HARD, BELOW O HORIZON`,
fragvol_wmn = `FRAGMENTS > 75MM WEIGHTED AVE. IN DEPTH 0-100CM`,
permdepth = `DEPTH TO PERMAFROST`,
floodfreq = `FLOODING FREQUENCY (Maximum Frequency)`,
depbrocksoft = `DEPTH TO BEDROCK SOFT, BELOW O HORIZON`,
lep = `LEP WTD_AVG 25-150cm OR ABOVE RESTRICTION, BELOW O HORIZON`,
slope_r = `SLOPE`,
depcementthick = `DEPTH TO CEMENTED PAN THICK, BELOW O HORIZON`,
restricthardness = `RESTRICTIVE FEATURE HARDNESS`,
depcementthin = `DEPTH TO CEMENTED PAN THIN, BELOW O HORIZON`,
totalsub_r = `SUBSIDENCE TOTAL`,
wt = `HIGH WATER TABLE DEPTH MINIMUM`,
gypsum = `SUBSIDENCE DUE TO GYPSUM, REV`,
bottomtexture = `UNIFIED BOTTOM LAYER`,
texmod = `USDA TEXTURE MODIFIER`,
texinlieu = `USDA TEXTURE (IN-LIEU-OF)`,
ponddur = `PONDING DURATION`,
pondfreq = `PONDING FREQUENCY`,
unstablefill = `COMPONENT LOCAL PHASE UNSTABLE FILL`,
impaction = `COMPONENT LOCAL PHASE IMPACTED`,
drainageclass = `DRAINAGE CLASS IS NOT SUBAQUEOUS`
) %>%
mutate(
texinlieu = as.factor(texinlieu),
texmod = as.factor(texmod),
permdepth = as.numeric(permdepth),
pondfreq = as.factor(pondfreq),
ponddur = as.factor(ponddur),
slope_r = as.numeric(slope_r),
totalsub_r = as.numeric(totalsub_r),
floodfreq = as.factor(floodfreq),
wt = as.numeric(wt),
lep = as.numeric(wt),
bottomtexture = as.factor(bottomtexture),
depbrockhard = as.numeric(depbrockhard),
depbrocksoft = as.numeric(depbrocksoft),
fragvol_wmn = as.numeric(fragvol_wmn),
restricthardness = as.factor(restricthardness),
depcementthick = as.numeric(depcementthick),
depcementthin = as.numeric(depcementthin),
unstablefill = as.factor(unstablefill),
gypsum = as.numeric(gypsum),
impaction = as.factor(impaction),
drainageclass = as.factor(drainageclass),
mukey = as.character(mukey),
cokey = as.character(cokey),
lkey = as.character(lkey),
muiid = as.character(muiid),
coiid = as.character(coiid),
liid = as.character(liid),
dmuiid = as.character(dmuiid),
comppct = as.integer(comppct)
) %>% # limit to only majority components, so it can be one to a map unit
arrange(
mukey,
-comppct
) %>%
group_by(
mukey
) %>%
summarise_all(
first
) %>% # do the conversion to logicals here
mutate(
pftex = grepl(pattern = "cpf", x = texinlieu) | grepl(pattern = "pf", x = texmod),
ponding =
(tolower(str_trim(ponddur)) %in% c("very brief", "brief", "long", "very long") & !is.na(ponddur)) |
(tolower(str_trim(pondfreq)) != "none" & !is.na(pondfreq)),
flooding = tolower(str_trim(floodfreq)) %in% c("very rare", "rare", "occasional", "frequent", "very frequent"),
organicsoil = grepl("(pt)|(ol)|(oh)", bottomtexture),
noncemented = tolower(str_trim(restricthardness)) == "noncemented",
unstablefill = unstablefill == "1",
impaction = impaction == "1",
drainageclass = drainageclass == "1"
)
head(t.nasisrename) # should have ~5 more columns than t.nasisjoin, and they should all have more concise names
test <- dwb_calc2(indata = t.nasisrename)
summary(as.factor(test$dwb)) # this should work! The code will run on any data frame with the right data and colnames
sf.mupolygon <- sf::st_read(dsn = path.gssurgo, layer = "MUPOLYGON") %>%
dplyr::rename(mukey = MUKEY) %>% st_transform(crs) %>% st_make_valid()
# limit to a test area ##
sf.mupolygon.subset <-
st_intersection(sf.mupolygon, sf.studyarea)
# attach all the nasis data to the study area polygon(s)
sf.nasis <-
left_join(sf.mupolygon.subset,
t.nasisrename,
by = "mukey")
head(sf.nasis) # again, v similar to the other head() calls.
#### 4 polygon to raster (SLOW!) ####
# create a template raster with the extent, crs, and resolution needed
r.template <-
raster(
extent(sf.studyarea),
resolution = res,
crs = crs
)
# name those layers! These must all be present as columns in t.nasisrename (and passed on to sf.nasis)
vec.layernames.dwb <-
c("permdepth", # permafrost depth
"slope_r", # mean slope
"totalsub_r", # total subsidence
"wt", # depth to water table
"lep",
"depbrockhard", # depth to hard bedrock
"depbrocksoft", # depth to soft bedrock
"fragvol_wmn", # weighted mean of rock fragments (theres more to this joe)
"restricthardness",
"depcementthick",
"depcementthin",
"unstablefill",
"gypsum",
"impaction",
"drainageclass",
"pftex",
"ponding",
"flooding",
"organicsoil",
"noncemented")
l.r <- sapply(
vec.layernames.dwb,
function(l){
print(l)
name <- paste0("Raster Properties/", outname, "_", l, ".tif")
print(name)
if(file.exists(name)){
r <- raster(name)
} else {
p <- sf.nasis[l]
r <- rasterize(
x = p,
field = l,
y = r.template,
filename = name,
driver = "GTiff"
)
}
return(r)
}
)
## send those rasters into a brick
brk <- brick(l.r) %>% mask(sf.studyarea)
names(brk) <- vec.layernames.dwb
# pass the brick into a data frame and run the calc function (can this switch to raster::calc()?)
df <- as.data.frame(brk)
df <- dwb_calc2(df)
# now send it back to the brick
brk$dwb <- brk$wt %>% setValues(factor(df$dwb), levels = rev(c("Not limited", "Somewhat limited", "Very limited"))) %>% mask(sf.studyarea)
brk$maxfuzz <- brk$wt %>% setValues(df$maxfuzz) %>% mask(sf.studyarea)
levelplot(brk$dwb, main = "Dwellings with Basements Interpretation")
plot(brk$maxfuzz)
brk$maxfuzz <- brk$wt %>% setValues(df$maxfuzz) %>% mask(sf.studyarea)
# name those layers! These must all be present as columns in t.nasisrename (and passed on to sf.nasis)
vec.layernames.dwb <-
c("permdepth", # permafrost depth
"slope_r", # mean slope
"totalsub_r", # total subsidence
"wt", # depth to water table
"lep",
"depbrockhard", # depth to hard bedrock
"depbrocksoft", # depth to soft bedrock
"fragvol_wmn", # weighted mean of rock fragments (theres more to this joe)
"restricthardness",
"depcementthick",
"depcementthin",
"unstablefill",
"gypsum",
"impaction",
"drainageclass",
"pftex",
"ponding",
"flooding",
"organicsoil",
"noncemented")
## send those rasters into a brick
brk <- brick(l.r) %>% mask(sf.studyarea)
l.r <- sapply(
vec.layernames.dwb,
function(l){
print(l)
name <- paste0("Raster Properties/", outname, "_", l, ".tif")
print(name)
if(file.exists(name)){
r <- raster(name)
} else {
p <- sf.nasis[l]
r <- rasterize(
x = p,
field = l,
y = r.template,
filename = name,
driver = "GTiff"
)
}
return(r)
}
)
brk <- brick(l.r)
plot(brk)
extent(brk)
extent(r.slope)
names(brk) <- vec.layernames.dwb
# pass the brick into a data frame and run the calc function (can this switch to raster::calc()?)
df <- as.data.frame(brk)
df <- dwb_calc2(df)
# now send it back to the brick
brk$dwb <- brk$wt %>% setValues(factor(df$dwb), levels = rev(c("Not limited", "Somewhat limited", "Very limited"))) %>% mask(sf.studyarea)
brk$maxfuzz <- brk$wt %>% setValues(df$maxfuzz) %>% mask(sf.studyarea)
levelplot(brk$dwb, main = "Dwellings with Basements Interpretation")
brk$dwb
brk$maxfuzz <- brk$wt %>% setValues(df$maxfuzz) %>% mask(sf.studyarea)
plot(brk$maxfuzz)
# pass the brick into a data frame and run the calc function (can this switch to raster::calc()?)
df <- as.data.frame(brk)
df <- dwb_calc2(df)
## send those rasters into a brick
brk <- brick(l.r) %>% mask(sf.studyarea)
names(brk) <- vec.layernames.dwb
plot(brk)
l.r
df$dwb
summary(df$dwb)
# now send it back to the brick
brk$dwb <- brk$wt %>% setValues(factor(df$dwb), levels = rev(c("Not limited", "Somewhat limited", "Very limited"))) %>% mask(sf.studyarea)
brk$dwb
plot(brk$dwb)
brk$wt
# now send it back to the brick
brk$dwb <- brk$permdepth %>% setValues(factor(df$dwb), levels = rev(c("Not limited", "Somewhat limited", "Very limited"))) %>% mask(sf.studyarea)
levelplot(brk$dwb, main = "Dwellings with Basements Interpretation")
brk$dwb
plot(brk$wt)
plot(brk$slope_r)
plot(brk)
## send those rasters into a brick
brk <- brick(l.r)# %>% mask(sf.studyarea)
names(brk) <- vec.layernames.dwb
# pass the brick into a data frame and run the calc function (can this switch to raster::calc()?)
df <- as.data.frame(brk)
df <- dwb_calc2(df)
summary(df$dwb)
# now send it back to the brick
brk$dwb <- brk$permdepth %>% setValues(factor(df$dwb), levels = rev(c("Not limited", "Somewhat limited", "Very limited"))) %>% mask(sf.studyarea)
brk$maxfuzz <- brk$wt %>% setValues(df$maxfuzz) %>% mask(sf.studyarea)
levelplot(brk$dwb, main = "Dwellings with Basements Interpretation")
brk$dwb
df$dwb
# now send it back to the brick
brk$dwb <- brk$permdepth %>% setValues(df$dwb, levels = rev(c("Not limited", "Somewhat limited", "Very limited"))) %>% mask(sf.studyarea)
levelplot(brk$dwb, main = "Dwellings with Basements Interpretation")
brk$dwb
df$dwb
# now send it back to the brick
brk$dwb <- brk$permdepth %>% setValues(factor(df$dwb), levels = rev(c("Not limited", "Somewhat limited", "Very limited")))
brk$maxfuzz <- brk$wt %>% setValues(df$maxfuzz) %>% mask(sf.studyarea)
levelplot(brk$dwb, main = "Dwellings with Basements Interpretation")
plot(brk$maxfuzz)
levelplot(brk$dwb, main = "Dwellings with Basements Interpretation")
plot(brk$maxfuzz)
brk$maxfuzz <- brk$wt %>% setValues(df$maxfuzz) %>% mask(sf.studyarea)
# now send it back to the brick
brk$dwb <- brk$wt %>% setValues(factor(df$dwb), levels = rev(c("Not limited", "Somewhat limited", "Very limited")))
brk$maxfuzz <- brk$wt %>% setValues(df$maxfuzz)
levelplot(brk$dwb, main = "Dwellings with Basements Interpretation")
plot(brk$maxfuzz)
plot(sf.studyarea)
crs(sf.studyarea)
crs(brk)
# aea
crs <- crs("+init=epsg:5070")
# set study area polygon (save a sf file to "sf.studyarea")
sf.studyarea <-
sf::st_read(dsn = "E:/NMSU/GIS/Utah_County_Boundaries-shp", layer = "Counties") %>%
st_make_valid() %>% st_transform(crs)
crs(sf.studyarea)
t <- projectRaster(brk, crs = crs)
plot(t)
## send those rasters into a brick
brk <- brick(l.r) %>% projectRaster(crs = crs) %>% mask(sf.studyarea)
plot(brk)
# now send it back to the brick
brk$dwb <- brk$wt %>% setValues(factor(df$dwb), levels = rev(c("Not limited", "Somewhat limited", "Very limited")))
# pass the brick into a data frame and run the calc function (can this switch to raster::calc()?)
df <- as.data.frame(brk)
df <- dwb_calc2(df)
summary(df$dwb)
# now send it back to the brick
brk$dwb <- brk$wt %>% setValues(factor(df$dwb), levels = rev(c("Not limited", "Somewhat limited", "Very limited")))
brk$maxfuzz <- brk$wt %>% setValues(df$maxfuzz)
levelplot(brk$dwb, main = "Dwellings with Basements Interpretation")
plot(brk$maxfuzz)
# now send it back to the brick
brk$dwb <- brk$wt %>% setValues(factor(df$dwb), levels = rev(c("Not limited", "Somewhat limited", "Very limited"))) %>% mask(sf.studyarea)
levelplot(brk$dwb, main = "Dwellings with Basements Interpretation")
plot(sf.studyarea)
county <- "GRAND"
# set study area polygon (save a sf file to "sf.studyarea")
sf.studyarea <-
sf::st_read(dsn = "E:/NMSU/GIS/Utah_County_Boundaries-shp", layer = "Counties") %>%
st_make_valid() %>% st_transform(crs)
if(!is.null(county))  sf.studyarea <- sf.studyarea %>% subset(NAME == county)
# pass the brick into a data frame and run the calc function (can this switch to raster::calc()?)
df <- as.data.frame(brk)
## send those rasters into a brick
brk <- brick(l.r) %>% projectRaster(crs = crs) %>% mask(sf.studyarea)
names(brk) <- vec.layernames.dwb
# pass the brick into a data frame and run the calc function (can this switch to raster::calc()?)
df <- as.data.frame(brk)
df <- dwb_calc2(df)
summary(df$dwb)
# now send it back to the brick
brk$dwb <- brk$wt %>% setValues(factor(df$dwb), levels = rev(c("Not limited", "Somewhat limited", "Very limited"))) %>% mask(sf.studyarea)
brk$maxfuzz <- brk$wt %>% setValues(df$maxfuzz) %>% mask(sf.studyarea)
levelplot(brk$dwb, main = "Dwellings with Basements Interpretation")
r.slope <- raster("E:/NMSU/Data/Slope/slope_pct_utGrand250.tif")
brk2 <- brk
brk2$slope_r <- r.slope
r.slope <- raster("E:/NMSU/Data/Slope/slope_pct_utGrand250.tif") %>% extend(sf.studyarea)
plot(r.slope)
extent(r.slope)
extent(brk)
test <- projectRaster(r.slope, brk)
brk$slope2 <- test
brk2 <- brk
brk2 <- brk
r.slope <- raster("E:/NMSU/Data/Slope/slope_pct_utGrand250.tif") %>% projectRaster(brk)
brk2 <- brk
brk2$slope_r <- r.slope
df2 <- as.data.frame(brk2)
df2 <- dwb_calc2(df2)
summary(df2$dwb)
# now send it back to the brick
brk2$dwb <- brk2$wt %>% setValues(factor(df2$dwb), levels = rev(c("Not limited", "Somewhat limited", "Very limited"))) %>% mask(sf.studyarea)
brk2$maxfuzz <- brk2$wt %>% setValues(df2$maxfuzz) %>% mask(sf.studyarea)
levelplot(brk2$dwb, main = "Dwellings with Basements Interpretation")
levelplot(brk$dwb, main = "Dwellings with Basements Interpretation")
writeRaster(brk$dwb, file = paste0(outfolder, "/", outname, "_dwb2.tif"), overwrite = T)
writeRaster(brk$dwb, file = paste0(outfolder, "/", outname, "_dwb_withDSMdata.tif"), overwrite = T)
writeRaster(brk2$dwb, file = paste0(outfolder, "/", outname, "_dwb_withDSMdata.tif"), overwrite = T)
levelplot(brk.subset$svi,
col.regions=terrain.colors(4),
xlab="Easting",
ylab="Northing")
brk.subset$hsg <-
brk.subset$wt %>% ## use a template raster. Data will be overwritten, just need crs & extent & etc
setValues(factor(df.spatialdata$hsg,
levels = (c("A", "A/D", "B", "B/D", "C", "C/D", "D"))))
test<-dwb_calc2(sf.nasis)
test <- dwb_calc2(sf.nasis)
df <- dwb_calc2(df)
t.nasisrename <- dwb_calc2(t.nasisrename)
t.nasisrename$dwb
t.nasisrename <- dwb_calc2(t.nasisrename)
st_write(t.nasisrename,
dsn = paste0(outfolder, "/", outname, "_dwbnasisdata.shp"),
#name = paste0(outname, "_nasisdata.shp"),
driver = "ESRI Shapefile",
append = F)
st_write(t.nasisrename,
dsn = paste0(outfolder, "/", outname, "_dwbnasisdata.shp"),
#name = paste0(outname, "_nasisdata.shp"),
driver = "ESRI Shapefile",
append = F)
st_write(t.nasisrename,
dsn = paste0(outfolder, "/", outname, "_dwbnasisdata.shp"),
#name = paste0(outname, "_nasisdata.shp"),
driver = "ESRI Shapefile",
append = F)
st_write(t.nasisrename,
dsn = paste0(outfolder, "/", outname, "_dwbnasisdata2.shp"),
#name = paste0(outname, "_nasisdata.shp"),
driver = "ESRI Shapefile",
append = F)
sf.nasis$dwb <- t.nasisrename$dwb
sf.nasis
sf.nasis@data
sf.nasis$dwb <- t.nasisrename$dwb
t.nasisrename <- dwb_calc2(t.nasisrename)
t.nasisrename <- dwb_calc2(indata = t.nasisrename)
summary(as.factor(t.nasisrename$dwb)) # this should work! The code will run on any data frame with the right data and colnames
# attach all the nasis data to the study area polygon(s)
sf.nasis <-
left_join(sf.mupolygon.subset,
t.nasisrename,
by = "mukey")
head(sf.nasis) # again, v similar to the other head() calls.
st_write(sf.nasis,
dsn = paste0(outfolder, "/", outname, "_dwbnasisdata.shp"),
#name = paste0(outname, "_nasisdata.shp"),
driver = "ESRI Shapefile",
append = F)
?st_write
gc()
st_write(sf.nasis,
dsn = paste0(outfolder, "/", outname, "_dwbnasisdata3.shp"),
#name = paste0(outname, "_nasisdata.shp"),
driver = "ESRI Shapefile",
append = F)
st_write(sf.nasis,
dsn = paste0(outfolder, "/", outname, "_dwbnasisdata.shp"),
#name = paste0(outname, "_nasisdata.shp"),
driver = "ESRI Shapefile",
append = F)
sf.nasis
st_write(sf.nasis,
dsn = paste0(outfolder, "/", outname, "_dwbnasisdata.shp"),
layer = "dwb",
#name = paste0(outname, "_nasisdata.shp"),
driver = "ESRI Shapefile",
append = F)
sf.nasis %>% select(dwb)
sf.nasis %>% dplyr::select(dwb)
st_write(sf.nasis %>% dplyr::select(dwb),
dsn = paste0(outfolder, "/", outname, "_dwbnasisdata.shp"),
#name = paste0(outname, "_nasisdata.shp"),
driver = "ESRI Shapefile",
append = F)
st_write(sf.nasis %>% dplyr::select(dwb),
dsn = paste0(outfolder, "/", outname, "_dwbnasisdata5.shp"),
#name = paste0(outname, "_nasisdata.shp"),
driver = "ESRI Shapefile",
append = F)
st_write(sf.nasis %>% dplyr::select(dwb),
dsn = paste0(outfolder, "/", outname, "_dwb_fromnasis.shp"),
#name = paste0(outname, "_nasisdata.shp"),
driver = "ESRI Shapefile",
append = F)
levelplot(brk2$dwb, main = "Dwellings with Basements Interpretation")
